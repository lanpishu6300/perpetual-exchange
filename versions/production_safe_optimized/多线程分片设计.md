# 多线程分片设计文档（更新版）

## 🎯 设计目标

通过**双重分片策略**实现多线程并行处理，进一步提升吞吐量：
- **交易模块**：按用户ID分片（account/订单管理/爆仓检查）
- **撮合模块**：按币对分片（matching engine）

### 目标性能

- **吞吐量目标**: 100-200 K orders/sec（从41.11 K/s提升2-5倍）
- **延迟目标**: 保持或降低（< 25 μs）
- **零数据丢失**: 完全保持

---

## 🏗️ 架构设计

### 双重分片策略

**交易模块分片键**: `user_id % num_trading_shards`
- Account管理
- 订单管理
- 爆仓检查

**撮合模块分片键**: `instrument_id % num_matching_shards`
- Matching Engine
- Order Book
- WAL

### 架构图

```
┌─────────────────────────────────────────────────────────┐
│  ShardedMatchingEngine (Router)                        │
│  - 路由交易模块请求到用户分片                           │
│  - 路由撮合请求到币对分片                              │
└─────────────────────────────────────────────────────────┘
              │
              ├──> Trading Shard 0 (User 0, 2, 4, ...)
              │    ├──> AccountManager
              │    ├──> OrderManager
              │    └──> LiquidationEngine
              │
              ├──> Trading Shard 1 (User 1, 3, 5, ...)
              │    ├──> AccountManager
              │    ├──> OrderManager
              │    └──> LiquidationEngine
              │
              └──> Trading Shard N-1
                   ├──> AccountManager
                   ├──> OrderManager
                   └──> LiquidationEngine
              │
              ├──> Matching Shard 0 (Instrument 0, 2, 4, ...)
              │    └──> ProductionMatchingEngineSafeOptimized
              │         ├──> OrderBook
              │         ├──> WAL Writer Thread
              │         └──> Sync Worker Thread
              │
              ├──> Matching Shard 1 (Instrument 1, 3, 5, ...)
              │    └──> ProductionMatchingEngineSafeOptimized
              │         ├──> OrderBook
              │         ├──> WAL Writer Thread
              │         └──> Sync Worker Thread
              │
              └──> Matching Shard M-1
                   └──> ProductionMatchingEngineSafeOptimized
                        ├──> OrderBook
                        ├──> WAL Writer Thread
                        └──> Sync Worker Thread
```

---

## 🔧 核心设计

### 1. 交易模块分片 (Trading Shard)

**职责**:
- 账户管理（余额检查、更新）
- 订单管理（订单状态、用户订单索引）
- 爆仓检查（用户持仓、风险检查）

**分片函数**:
```cpp
size_t trading_shard_id = user_id % num_trading_shards;
```

**实现**:
```cpp
class TradingShard {
    // Account management
    AccountBalanceManager account_manager_;
    
    // Order management
    std::unordered_map<UserID, std::vector<OrderID>> user_orders_;
    
    // Liquidation engine
    LiquidationEngine liquidation_engine_;
    
    // Process order (account/validation)
    bool validate_and_prepare_order(Order* order);
    
    // Check liquidation
    bool check_liquidation(UserID user_id, InstrumentID instrument_id);
};
```

---

### 2. 撮合模块分片 (Matching Shard)

**职责**:
- 订单撮合
- Order Book管理
- WAL写入

**分片函数**:
```cpp
size_t matching_shard_id = instrument_id % num_matching_shards;
```

**实现**:
```cpp
class MatchingShard {
    // Matching engine
    ProductionMatchingEngineSafeOptimized engine_;
    
    // Process order (matching)
    std::vector<Trade> process_order(Order* order);
};
```

---

### 3. 协调层 (Coordinator)

**职责**:
- 路由订单到正确的分片
- 协调交易模块和撮合模块
- 处理跨分片操作（如果需要）

**流程**:
```
1. 订单到达
   ↓
2. 路由到交易模块分片 (按user_id)
   ├──> 账户验证
   ├──> 余额检查
   ├──> 爆仓检查
   └──> 订单准备
   ↓
3. 路由到撮合模块分片 (按instrument_id)
   ├──> 订单撮合
   ├──> 生成交易
   └──> WAL写入
   ↓
4. 返回交易模块分片 (按user_id)
   ├──> 更新账户余额
   ├──> 更新持仓
   └──> 更新订单状态
   ↓
5. 返回结果
```

---

## 📊 性能分析

### 预期提升

**当前性能**:
- 吞吐量: 41.11 K/s
- 单线程处理

**分片后预期**:
- 吞吐量: 100-200 K/s（2-5倍提升）
- 多线程并行处理
- 无锁竞争（分片隔离）

### 提升原因

1. **并行处理**: 
   - 交易模块：多个用户分片同时处理
   - 撮合模块：多个币对分片同时处理

2. **无锁竞争**: 
   - 交易模块：不同用户分片之间无共享状态
   - 撮合模块：不同币对分片之间无共享状态

3. **缓存局部性**: 
   - 交易模块：用户数据更集中
   - 撮合模块：币对数据更集中

4. **CPU利用率**: 充分利用多核CPU

---

## 🛡️ 零数据丢失保证

### 保证机制

1. **每个撮合分片独立的WAL**: 每个币对分片有自己的WAL文件
2. **分片内零数据丢失**: 每个分片内部保持零数据丢失保证
3. **交易模块状态一致性**: 交易模块分片需要保证状态一致性

**实现**:
```cpp
std::vector<Trade> ShardedMatchingEngine::process_order(Order* order) {
    // 1. 路由到交易模块分片（按user_id）
    size_t trading_shard_id = order->user_id % num_trading_shards_;
    auto* trading_shard = trading_shards_[trading_shard_id].get();
    
    // 2. 交易模块验证和准备
    if (!trading_shard->validate_and_prepare_order(order)) {
        return {};
    }
    
    // 3. 路由到撮合模块分片（按instrument_id）
    size_t matching_shard_id = order->instrument_id % num_matching_shards_;
    auto* matching_shard = matching_shards_[matching_shard_id].get();
    
    // 4. 撮合（内部保证零数据丢失）
    auto trades = matching_shard->process_order_optimized(order);
    
    // 5. 返回交易模块分片更新状态
    trading_shard->update_after_trade(order, trades);
    
    return trades;
}
```

---

## 🔍 潜在问题与解决方案

### 问题1: 跨分片状态同步

**问题**: 交易模块和撮合模块在不同分片，需要同步状态

**解决方案**: 
- 交易模块分片负责账户和订单状态
- 撮合模块分片负责撮合和WAL
- 通过返回值同步状态

---

### 问题2: 同一用户不同币对

**问题**: 同一用户可能交易多个币对，需要访问多个撮合分片

**解决方案**: 
- 这是正常的，每个币对独立撮合
- 交易模块分片统一管理用户的所有订单

---

### 问题3: 分片数量选择

**问题**: 交易分片和撮合分片数量如何选择？

**解决方案**:
- **交易分片**: 建议 = CPU核心数（用户数据访问模式）
- **撮合分片**: 建议 = 币对数量或CPU核心数（撮合计算密集）
- 可以独立配置

---

## 📝 实施计划

### 阶段1: 实现交易模块分片

1. 创建TradingShard类
2. 实现按用户ID分片
3. 集成AccountManager、OrderManager、LiquidationEngine

### 阶段2: 实现撮合模块分片

1. 创建MatchingShard类（已部分完成）
2. 实现按币对ID分片
3. 每个分片独立的MatchingEngine和WAL

### 阶段3: 实现协调层

1. 创建ShardedMatchingEngine协调类
2. 实现订单路由逻辑
3. 协调交易模块和撮合模块

### 阶段4: 测试验证

1. 功能测试
2. 性能测试
3. 零数据丢失验证

---

## 📈 预期效果

### 性能提升

| 指标 | 当前 | 预期 | 提升 |
|------|------|------|------|
| **吞吐量** | 41.11 K/s | **100-200 K/s** | **2-5倍** ⬆️ |
| **平均延迟** | 22.47 μs | **15-20 μs** | **10-30%** ⬇️ |
| **P99延迟** | 114.25 μs | **50-80 μs** | **30-50%** ⬇️ |

### 关键优势

1. ✅ **双重并行**: 交易模块和撮合模块同时并行
2. ✅ **无锁竞争**: 分片隔离，无共享状态
3. ✅ **零数据丢失**: 每个撮合分片独立保证
4. ✅ **可扩展性**: 可以独立调整分片数量

---

**设计日期**: 2024-12-19  
**更新**: 双重分片策略（交易模块按用户，撮合模块按币对）
