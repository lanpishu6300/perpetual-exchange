#include "trading_service_cqrs.h"
#include "core/order.h"
#include "core/types.h"
#include "core/matching_engine_event_sourcing.h"
#include <grpcpp/grpcpp.h>

namespace perpetual {
namespace trading {

// TradingCommandHandler Implementation
TradingCommandHandler::TradingCommandHandler(const std::string& matching_service_address)
    : matching_service_address_(matching_service_address) {
    connect_to_matching_service();
}

void TradingCommandHandler::connect_to_matching_service() {
    matching_channel_ = grpc::CreateChannel(
        matching_service_address_,
        grpc::InsecureChannelCredentials()
    );
    matching_stub_ = MatchingService::NewStub(matching_channel_);
}

CommandResult TradingCommandHandler::handleCommand(const TradingCommand& command) {
    switch (command.type) {
        case TradingCommand::SUBMIT_ORDER:
            return handleSubmitOrder(command);
        case TradingCommand::CANCEL_ORDER:
            return handleCancelOrder(command);
        default:
            CommandResult result;
            result.success = false;
            result.error_message = "Unknown command type";
            return result;
    }
}

CommandResult TradingCommandHandler::handleSubmitOrder(const TradingCommand& command) {
    CommandResult result;
    
    // Validate order
    if (!order_validator_) {
        result.error_message = "Order validator not set";
        return result;
    }
    
    Order order(command.order_id, command.user_id, command.instrument_id,
               command.side, command.price, command.quantity, command.order_type);
    
    auto validation = order_validator_->validate(&order);
    if (!validation.valid) {
        result.success = false;
        result.error_message = validation.reason;
        return result;
    }
    
    // Check account balance
    if (!account_manager_) {
        result.error_message = "Account manager not set";
        return result;
    }
    
    double required_margin = (static_cast<double>(command.price) / PRICE_SCALE) *
                            (static_cast<double>(command.quantity) / QTY_SCALE) / 10.0;
    if (!account_manager_->hasSufficientBalance(command.user_id, required_margin)) {
        result.success = false;
        result.error_message = "Insufficient margin";
        return result;
    }
    
    // Check position limit
    if (!position_manager_) {
        result.error_message = "Position manager not set";
        return result;
    }
    
    if (!position_manager_->checkPositionLimit(command.user_id, command.instrument_id,
                                              command.quantity, command.side)) {
        result.success = false;
        result.error_message = "Position limit exceeded";
        return result;
    }
    
    // Freeze margin
    if (!account_manager_->freezeBalance(command.user_id, required_margin)) {
        result.success = false;
        result.error_message = "Failed to freeze balance";
        return result;
    }
    
    // Call matching service
    OrderRequest match_request;
    match_request.set_order_id(command.order_id);
    match_request.set_user_id(command.user_id);
    match_request.set_instrument_id(command.instrument_id);
    match_request.set_side(command.side == OrderSide::BUY ? 
                          OrderSide::ORDER_SIDE_BUY : OrderSide::ORDER_SIDE_SELL);
    match_request.set_order_type(static_cast<OrderType>(command.order_type));
    match_request.set_price(command.price);
    match_request.set_quantity(command.quantity);
    match_request.set_sequence_id(get_current_timestamp());
    
    MatchResult match_result;
    grpc::ClientContext client_context;
    grpc::Status status = matching_stub_->ProcessOrder(
        &client_context, match_request, &match_result);
    
    if (!status.ok() || !match_result.success()) {
        account_manager_->unfreezeBalance(command.user_id, required_margin);
        result.success = false;
        result.error_message = match_result.error_message();
        return result;
    }
    
    // Generate events (would be generated by matching service)
    // For now, create placeholder events
    Event order_placed_event;
    order_placed_event.type = EventType::ORDER_PLACED;
    order_placed_event.sequence_id = get_current_timestamp();
    // ... fill event data
    
    result.success = true;
    result.order_id = command.order_id;
    
    return result;
}

CommandResult TradingCommandHandler::handleCancelOrder(const TradingCommand& command) {
    CommandResult result;
    
    // Call matching service to cancel
    CancelOrderRequest cancel_request;
    cancel_request.set_order_id(command.order_id);
    cancel_request.set_user_id(command.user_id);
    cancel_request.set_instrument_id(command.instrument_id);
    
    CancelOrderResponse cancel_response;
    grpc::ClientContext client_context;
    grpc::Status status = matching_stub_->CancelOrder(
        &client_context, cancel_request, &cancel_response);
    
    if (!status.ok() || !cancel_response.success()) {
        result.success = false;
        result.error_message = "Failed to cancel order";
        return result;
    }
    
    result.success = true;
    
    return result;
}

// TradingQueryHandler Implementation
TradingQueryHandler::TradingQueryHandler(EventStore* event_store)
    : event_store_(event_store) {
    // Rebuild views from events on initialization
    rebuildViewsFromEvents();
}

OrderView TradingQueryHandler::getOrder(OrderID order_id) {
    std::shared_lock<std::shared_mutex> lock(views_mutex_);
    auto it = order_views_.find(order_id);
    if (it != order_views_.end()) {
        return it->second;
    }
    return OrderView{};  // Return empty view
}

std::vector<OrderView> TradingQueryHandler::getUserOrders(UserID user_id,
                                                          InstrumentID instrument_id,
                                                          OrderStatus status) {
    std::shared_lock<std::shared_mutex> lock(views_mutex_);
    std::vector<OrderView> orders;
    
    auto it = user_order_index_.find(user_id);
    if (it == user_order_index_.end()) {
        return orders;
    }
    
    for (OrderID order_id : it->second) {
        auto order_it = order_views_.find(order_id);
        if (order_it == order_views_.end()) continue;
        
        const OrderView& view = order_it->second;
        
        // Filter by instrument
        if (instrument_id != 0 && view.instrument_id != instrument_id) {
            continue;
        }
        
        // Filter by status
        if (status != static_cast<OrderStatus>(255) && view.status != status) {
            continue;
        }
        
        orders.push_back(view);
    }
    
    return orders;
}

AccountView TradingQueryHandler::getAccount(UserID user_id) {
    std::shared_lock<std::shared_mutex> lock(views_mutex_);
    auto it = account_views_.find(user_id);
    if (it != account_views_.end()) {
        return it->second;
    }
    return AccountView{};  // Return empty view
}

PositionView TradingQueryHandler::getPosition(UserID user_id, InstrumentID instrument_id) {
    std::shared_lock<std::shared_mutex> lock(views_mutex_);
    auto user_it = position_views_.find(user_id);
    if (user_it == position_views_.end()) {
        return PositionView{};
    }
    
    auto inst_it = user_it->second.find(instrument_id);
    if (inst_it != user_it->second.end()) {
        return inst_it->second;
    }
    
    return PositionView{};
}

std::vector<PositionView> TradingQueryHandler::getUserPositions(UserID user_id) {
    std::shared_lock<std::shared_mutex> lock(views_mutex_);
    std::vector<PositionView> positions;
    
    auto user_it = position_views_.find(user_id);
    if (user_it == position_views_.end()) {
        return positions;
    }
    
    for (const auto& pair : user_it->second) {
        positions.push_back(pair.second);
    }
    
    return positions;
}

void TradingQueryHandler::updateViewsFromEvent(const Event& event) {
    std::unique_lock<std::shared_mutex> lock(views_mutex_);
    
    switch (event.type) {
        case EventType::ORDER_PLACED:
        case EventType::ORDER_UPDATED:
        case EventType::ORDER_CANCELLED:
            updateOrderView(event);
            break;
        case EventType::TRADE_EXECUTED:
            updateOrderView(event);
            updateAccountView(event);
            updatePositionView(event);
            break;
        default:
            break;
    }
}

void TradingQueryHandler::rebuildViewsFromEvents() {
    if (!event_store_) {
        return;
    }
    
    // Get all events and rebuild views
    auto events = event_store_->get_events(0, UINT64_MAX);
    
    std::unique_lock<std::shared_mutex> lock(views_mutex_);
    order_views_.clear();
    account_views_.clear();
    position_views_.clear();
    user_order_index_.clear();
    
    for (const auto& event : events) {
        updateViewsFromEvent(event);
    }
}

void TradingQueryHandler::updateOrderView(const Event& event) {
    // Update order view from event
    // Implementation depends on event structure
    // Placeholder implementation
}

void TradingQueryHandler::updateAccountView(const Event& event) {
    // Update account view from event
    // Placeholder implementation
}

void TradingQueryHandler::updatePositionView(const Event& event) {
    // Update position view from event
    // Placeholder implementation
}

// TradingServiceCQRS Implementation
TradingServiceCQRS::TradingServiceCQRS(const std::string& matching_service_address,
                                      EventStore* event_store)
    : event_store_(event_store) {
    if (!event_store_) {
        event_store_ = new EventStore();
        owns_event_store_ = true;
    }
    
    command_handler_ = std::make_unique<TradingCommandHandler>(matching_service_address);
    query_handler_ = std::make_unique<TradingQueryHandler>(event_store_);
    
    order_validator_ = std::make_unique<OrderValidator>();
    account_manager_ = std::make_unique<AccountBalanceManager>();
    position_manager_ = std::make_unique<PositionManager>();
    
    command_handler_->setOrderValidator(order_validator_.get());
    command_handler_->setAccountManager(account_manager_.get());
    command_handler_->setPositionManager(position_manager_.get());
    
    event_processor_ = std::make_unique<EventStreamProcessor>(event_store_);
}

TradingServiceCQRS::~TradingServiceCQRS() {
    stop();
    if (owns_event_store_ && event_store_) {
        delete event_store_;
    }
}

bool TradingServiceCQRS::initialize() {
    if (owns_event_store_ && event_store_) {
        if (!event_store_->initialize("./event_store")) {
            return false;
        }
    }
    
    // Subscribe to events for view updates
    event_processor_->subscribe([this](const Event& event) {
        query_handler_->updateViewsFromEvent(event);
    });
    
    event_processor_->start_processing();
    
    return true;
}

void TradingServiceCQRS::start(const std::string& server_address) {
    if (running_) {
        return;
    }
    
    grpc::ServerBuilder builder;
    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
    builder.RegisterService(this);
    
    grpc_server_ = builder.BuildAndStart();
    if (grpc_server_) {
        running_ = true;
    }
}

void TradingServiceCQRS::stop() {
    if (!running_) {
        return;
    }
    
    running_ = false;
    if (event_processor_) {
        event_processor_->stop_processing();
    }
    if (grpc_server_) {
        grpc_server_->Shutdown();
    }
}

grpc::Status TradingServiceCQRS::SubmitOrder(grpc::ServerContext* context,
                                            const SubmitOrderRequest* request,
                                            SubmitOrderResponse* response) {
    // Convert to command
    TradingCommand command;
    command.type = TradingCommand::SUBMIT_ORDER;
    command.user_id = request->user_id();
    command.instrument_id = request->instrument_id();
    command.order_id = next_order_id_++;
    command.side = request->side() == OrderSide::ORDER_SIDE_BUY ? 
                   OrderSide::BUY : OrderSide::SELL;
    command.order_type = static_cast<OrderType>(request->order_type());
    command.price = request->price();
    command.quantity = request->quantity();
    
    // Execute command
    CommandResult result = command_handler_->handleCommand(command);
    
    if (result.success) {
        response->set_success(true);
        response->set_order_id(result.order_id);
    } else {
        response->set_success(false);
        response->set_error_message(result.error_message);
    }
    
    return grpc::Status::OK;
}

grpc::Status TradingServiceCQRS::CancelOrder(grpc::ServerContext* context,
                                            const CancelOrderRequest* request,
                                            CancelOrderResponse* response) {
    TradingCommand command;
    command.type = TradingCommand::CANCEL_ORDER;
    command.order_id = request->order_id();
    command.user_id = request->user_id();
    
    CommandResult result = command_handler_->handleCommand(command);
    
    response->set_success(result.success);
    if (!result.success) {
        response->set_error_message(result.error_message);
    }
    
    return grpc::Status::OK;
}

grpc::Status TradingServiceCQRS::QueryOrder(grpc::ServerContext* context,
                                           const QueryOrderRequest* request,
                                           QueryOrderResponse* response) {
    OrderView view = query_handler_->getOrder(request->order_id());
    
    if (view.order_id == 0) {
        response->set_success(false);
        response->set_error_message("Order not found");
        return grpc::Status::OK;
    }
    
    // Convert to response
    OrderInfo* order_info = response->mutable_order();
    order_info->set_order_id(view.order_id);
    order_info->set_user_id(view.user_id);
    order_info->set_instrument_id(view.instrument_id);
    order_info->set_side(static_cast<OrderSide>(view.side));
    order_info->set_order_type(static_cast<OrderType>(view.order_type));
    order_info->set_price(view.price);
    order_info->set_quantity(view.quantity);
    order_info->set_filled_quantity(view.filled_quantity);
    order_info->set_remaining_quantity(view.remaining_quantity);
    order_info->set_status(static_cast<OrderStatus>(view.status));
    order_info->set_timestamp(view.timestamp);
    
    response->set_success(true);
    return grpc::Status::OK;
}

grpc::Status TradingServiceCQRS::QueryUserOrders(grpc::ServerContext* context,
                                                const QueryUserOrdersRequest* request,
                                                QueryUserOrdersResponse* response) {
    auto views = query_handler_->getUserOrders(
        request->user_id(),
        request->instrument_id(),
        static_cast<OrderStatus>(request->status())
    );
    
    for (const auto& view : views) {
        OrderInfo* order_info = response->add_orders();
        order_info->set_order_id(view.order_id);
        order_info->set_user_id(view.user_id);
        order_info->set_instrument_id(view.instrument_id);
        order_info->set_side(static_cast<OrderSide>(view.side));
        order_info->set_order_type(static_cast<OrderType>(view.order_type));
        order_info->set_price(view.price);
        order_info->set_quantity(view.quantity);
        order_info->set_filled_quantity(view.filled_quantity);
        order_info->set_remaining_quantity(view.remaining_quantity);
        order_info->set_status(static_cast<OrderStatus>(view.status));
        order_info->set_timestamp(view.timestamp);
    }
    
    response->set_success(true);
    return grpc::Status::OK;
}

grpc::Status TradingServiceCQRS::QueryAccount(grpc::ServerContext* context,
                                             const QueryAccountRequest* request,
                                             QueryAccountResponse* response) {
    AccountView view = query_handler_->getAccount(request->user_id());
    
    AccountInfo* account = response->mutable_account();
    account->set_user_id(view.user_id);
    account->set_balance(view.balance);
    account->set_frozen(view.frozen);
    account->set_available(view.available);
    account->set_used_margin(view.used_margin);
    
    response->set_success(true);
    return grpc::Status::OK;
}

grpc::Status TradingServiceCQRS::QueryPosition(grpc::ServerContext* context,
                                              const QueryPositionRequest* request,
                                              QueryPositionResponse* response) {
    if (request->instrument_id() != 0) {
        PositionView view = query_handler_->getPosition(
            request->user_id(), request->instrument_id());
        
        if (view.instrument_id != 0) {
            PositionInfo* position = response->add_positions();
            position->set_user_id(view.user_id);
            position->set_instrument_id(view.instrument_id);
            position->set_size(view.size);
            position->set_entry_price(view.entry_price);
        }
    } else {
        auto views = query_handler_->getUserPositions(request->user_id());
        for (const auto& view : views) {
            PositionInfo* position = response->add_positions();
            position->set_user_id(view.user_id);
            position->set_instrument_id(view.instrument_id);
            position->set_size(view.size);
            position->set_entry_price(view.entry_price);
        }
    }
    
    response->set_success(true);
    return grpc::Status::OK;
}

void TradingServiceCQRS::startViewUpdate() {
    if (event_processor_) {
        event_processor_->start_processing();
    }
}

void TradingServiceCQRS::stopViewUpdate() {
    if (event_processor_) {
        event_processor_->stop_processing();
    }
}

} // namespace trading
} // namespace perpetual

